#!/bin/bash
# Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

FLAGS_HELP="
usage: ./bin/concat.sh -i FILE -o FILE [-f]

This script concatenates a list of files into a single file.  The list of files
is supplied via text file, using the -i|--input_from argument.  The filenames
can be relative to the working directory or located in a directory listed in
LIBDOT_CONCAT_PATH.  Absolute paths also work, but should probably be avoided.

If the -f|--forever argument is provided, then the script will monitor the
list of input files and recreate the output when it detects a change.

The environment variable LIBDOT_CONCAT_PATH can be used to define a search
path.  It's consulted when resolving input files, and lets you specifiy relative
paths in the input file without imposing a parent directory structure.
"

# See <http://code.google.com/p/shflags/>.
source "$(dirname $0)/shflags"

DEFINE_boolean forever "$FLAGS_FALSE" \
  "Recreate the output file whenever one of the inputs changes. " f
DEFINE_string input_from '' \
  "A file containing the list of files to concatenate." i
DEFINE_string output '' \
  "The output file." o

COMMAND_LINE="$(readlink -f $0) $@"
FLAGS "$@" || exit $?
eval set -- "${FLAGS_ARGV}"

if [ -z "$LIBDOT_CONCAT_PATH" ]; then
  LIBDOT_CONCAT_PATH="./"
fi

function insist() {
  local err=$?

  if [ ! -z "$1" ]; then
    "$@"
    err=$?
  fi

  if [ $err != 0 ]; then
    if [ -z "$1" ]; then
      echo_err "Command returned exit code: $err"
    else
      echo_err "Command $* returned exit code: $err"
    fi

    exit $err
  fi
}

function echo_err() {
  echo "-*- $*" >&2
}

function append_output() {
  echo $@ >> "$FLAGS_output"
}

function append_comment() {
  local str=$*

  if [ -z "$str" ]; then
    append_output "//"
    return
  fi

  # Wrapping at 76 gives us 79 columns with the "// " and trailing escape.
  # Testing at 77 ensures we've got something to wrap.
  while [ ${#str} -gt 77 ]; do
    append_output "// ${str:0:76}\\"
    str="${str:76}"
  done

  append_output "// $str"
}

function echo_header() {
  append_comment "This file was generated by libdot/bin/concat.sh."
  append_comment "It has been marked read-only for your safety.  Rather"
  append_comment "than edit it directly, please modify one of these source"
  append_comment "files..."
  append_comment

  local raw_input=$(read_input_from $FLAGS_input_from)

  for f in $raw_input; do
    append_comment "$f"
  done

  append_comment
  append_output
}

function echo_files() {
  for f in "$@"; do
    append_comment "SOURCE FILE: $f"
    insist cat $f >> "$FLAGS_output"
  done
}

function concat() {
  local input=$*

  if [ ! -z "$FLAGS_output" ]; then
    echo $(date "+%H:%M:%S") "- Re-creating: $FLAGS_output" >&2
    touch "$FLAGS_output"
    insist chmod u+w "$FLAGS_output"
    insist echo -n "" > "$FLAGS_output"
    insist echo_header
    insist echo_files "$input"
    insist chmod a-w "$FLAGS_output"
  else
    insist cat $input
  fi
}

function search_file() {
  local filename="$1"

  local oldifs="$IFS"
  IFS=":"

  for dir in $LIBDOT_CONCAT_PATH; do
    if [ -e "$dir/$filename" ]; then
      echo "$dir/$filename"
      return
    fi
  done

  IFS=oldifs
}

function normalize_input() {
  local input=$@

  for path in $input; do
    local abspath=$(search_file "$path")
    if [ -z "$abspath" ]; then
      echo_err "Can't find '$path' in $LIBDOT_CONCAT_PATH"
      return 1
    fi

    echo "$abspath"
  done

  return 0
}

function read_input_from() {
  local filename="$1"

  exec 3< "$filename"

  while read -r 0<&3 LINE; do
    LINE=${LINE##} #  Strip leading spaces.
    if [ "${LINE:0:1}" = '#' ]; then
      # Skip comment.
      continue
    fi

    echo "${LINE}"
  done
}

function main() {
  local input=""

  if [ ! -z "$FLAGS_input_from" ]; then
    raw_input=$(read_input_from $FLAGS_input_from)
    insist
  else
    raw_input=$*
  fi

  input=$(normalize_input $raw_input)
  insist

  insist concat $input

  if [ "$FLAGS_forever" = "$FLAGS_TRUE" ]; then
    inotifywait -qqe modify $0 $FLAGS_input_from $input
    local err=$?
    if [[ $err != 0 && $err != 1 ]]; then
      echo_err "inotify exited with status code: $err"
      exit $err
    fi

    exec $COMMAND_LINE
  fi

  return 0
}

main "$@"
